<p>本文为<a href="https://github.com/ipChrisLee/moe/tree/KousakaReina-1.0.0">moe库初代版本KousakaReina</a>的介绍性文档，主要介绍moe库的来源，以及各个部分的用法和设计逻辑和常用场景。</p>
<span id="more"></span>

<p><img src="/2022/12/02/moe%E5%BA%93KousakaReina%E7%89%88%E6%9C%AC%E8%AE%BE%E8%AE%A1%E4%BB%8B%E7%BB%8D/KousakaReina.jpeg" alt="KousakaReina"></p>
<p>Kousaka Reina镇楼（误）。</p>
<h1 id="moe库的起源"><a href="#moe库的起源" class="headerlink" title="moe库的起源"></a>moe库的起源</h1><p>本人ipLee在参加<a href="https://compiler.educg.net/#/index?name=2022%E5%85%A8%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E8%83%BD%E5%8A%9B%E5%A4%A7%E8%B5%9B%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E8%B5%9B&index=1&img=0">2022全国大学生计算机系统能力大赛编译系统设计赛</a>时第一次写大项目，当时考虑到大项目需要一些比较常用的功能，于是自己实现了一个库。当时编译系统设计赛我的作品名为MoeCompiler，意为“萌编译器”（neta自萌娘百科网址moegirl.org.cn），于是这个来自于MoeCompiler的支持开发的库就命名成了moe。</p>
<p>值得注意的是，当时<a href="https://github.com/ipChrisLee/MoeCompiler/tree/moe/src/mlib">MoeCompiler使用的moe库</a>有非常明显的<a href="https://www.zhihu.com/question/19993179">过度设计</a>的倾向，最直接的表现是：大多数我亲手写下的代码并不会被我自己用上哪怕一次，而用得上的代码里相当一部分又因为设计缺少思考导致极其难用。在吸取了这个教训之后，我改良了整个库的设计，让它保证：</p>
<ul>
<li>需要时增加。</li>
<li>设计尽可能简单。</li>
<li>“傻子”都能使用。</li>
</ul>
<p>并且我也参考了很多其他项目、语言（主要是Rust）的精华，具体设计思路可以参考文档。</p>
<p>我已经在多个个人项目中使用了现在版本的moe库，个人感觉是省下了很多时间的。</p>
<p>本代码库使用GPL-2.0开源协议。</p>
<p>此外，如果你有任何想法， 可以pr，或者直接微信&#x2F;邮箱和我交流。</p>
<h1 id="moe库的编译环境"><a href="#moe库的编译环境" class="headerlink" title="moe库的编译环境"></a>moe库的编译环境</h1><p>moe是C++库，语言标准是C++17，本地使用下述clang++版本编译过，未出现问题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Homebrew clang version 15.0.3</span><br><span class="line">Target: x86_64-apple-darwin21.6.0</span><br><span class="line">Thread model: posix</span><br></pre></td></tr></table></figure>

<p>如果你发现在你的本地无法正常编译，欢迎提issue和我交流。</p>
<h1 id="库的基本特征"><a href="#库的基本特征" class="headerlink" title="库的基本特征"></a>库的基本特征</h1><ul>
<li><p>名空间保护：</p>
<p>几乎所有的特性都是用<code>moe</code>这个<code>namespace</code>包裹。</p>
<p>对于宏这种没有namespace的东西，都使用<code>moe_</code>作为前缀，防止与其他库放在一起冲突。</p>
</li>
<li><p>编译保护：</p>
<p>所有hpp文件都加了<code>#pragma once</code>，防止重定义。</p>
</li>
</ul>
<h1 id="分库介绍"><a href="#分库介绍" class="headerlink" title="分库介绍"></a>分库介绍</h1><h2 id="moe-typedef-hpp"><a href="#moe-typedef-hpp" class="headerlink" title="moe_typedef.hpp"></a>moe_typedef.hpp</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><a href="https://github.com/ipChrisLee/moe/blob/KousakaReina-1.0.0/moe/moe_typedef.hpp">moe_typedef.hpp</a>里引入了一些对整数的重命名。比如用<code>i32</code>代替一般意义下的<code>int</code>。</p>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>include这个文件之后，就可以直接使用诸如<code>i32</code>、<code>i8</code>这些定义。</p>
<p>具体有<code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>。</p>
<h3 id="为什么要设计这个库"><a href="#为什么要设计这个库" class="headerlink" title="为什么要设计这个库"></a>为什么要设计这个库</h3><p>在C&#x2F;C++中，<code>int</code>、<code>long</code>、<code>long long</code>这种整数类型的语义其实是不太完全的：你无法第一眼就明白一个<code>long</code>是32位的（当然熟悉C&#x2F;C++的人是可以马上反应过来的，但是这终究不是“第一反应”），一个<code>long long</code>是64位的，更别提<code>int</code>在不同的机器上位数还不一样。</p>
<p>在Rust中，这些整数类型都变成了语义明确的<code>i32</code>、<code>i64</code>，我也参考了这个设计。</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>但是目前的moe_typedef.hpp有一个非常严重的问题：这种类型定义肯定是越简单越好，所以我没有为它引入namespace，但是举个例子，比如你代码已经有对<code>i32</code>做了定义，再直接&#x2F;间接include了这个文件这就会产生冲突。</p>
<p>为了兼容性，这个大版本的moe库可能不会着手这个问题。当然我也没想清楚应该怎么解决这个问题。。。如果您有想法欢迎和我交流。</p>
<p>此外还有一个问题：由于C语言遗留问题，所以<code>i8</code>虽然语义上是一个整数，但是被<code>ostream</code>输出时会被当作一个<code>char</code>。。。这个也属于不好解决的问题。</p>
<h2 id="moe-macro-hpp"><a href="#moe-macro-hpp" class="headerlink" title="moe_macro.hpp"></a>moe_macro.hpp</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>这个文件里都是一些库里需要用到的宏定义，包括字符串拼接之类的。</p>
<p>这些宏全部使用<code>MOE_</code>开头，避免出现重定义。</p>
<p>大多数情况下你不需要直接使用这个库。</p>
<h2 id="rt-check-hpp"><a href="#rt-check-hpp" class="headerlink" title="rt_check.hpp"></a>rt_check.hpp</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p>这里rt是runtime的意思。</p>
<p>这个文件引入了运行时代码检测，包括：</p>
<ul>
<li><code>moe_panic(msg)</code>宏，输出消息、当前位置并直接结束程序的宏。</li>
<li>执行了就会输出位置并直接结束的<code>moe_rt_todo()</code>宏。</li>
<li>判断传入条件真假，为假就会输出消息、当前程序位置并直接结束程序的<code>moe_assert(...)</code>宏。</li>
</ul>
<h3 id="为什么要设计这个库-1"><a href="#为什么要设计这个库-1" class="headerlink" title="为什么要设计这个库"></a>为什么要设计这个库</h3><p>在项目设计中，assert和todo可以说是非常常用的函数（它们常用到Rust专门在语言层面支持了它们），但是在C++中，只有比较残废的assert，todo甚至没有。</p>
<h4 id="关于assert的重要性"><a href="#关于assert的重要性" class="headerlink" title="关于assert的重要性"></a>关于assert的重要性</h4><p>下图部分介绍了bug是fault-&gt;error-&gt;failuer的顺序来的，而assert的作用就是限制这个传播链，让error尽可能马上地暴露出来，进而尽快定位到底在哪错了。</p>
<p><img src="/../../../../Proj/moe/docs/src_to_doc/DebugTheory.png"></p>
<p>这个图来自<a href="https://www.bilibili.com/video/BV1824y127cX">DiffTest介绍(余子濠, 王华强) [第三期“一生一芯”计划 - P5]</a>的11分钟左右。我个人不是很喜欢“一生一芯”项目里的部分做法，不过这个视频还是很有意思的。</p>
<h4 id="关于todo的重要性"><a href="#关于todo的重要性" class="headerlink" title="关于todo的重要性"></a>关于todo的重要性</h4><p>写代码时有时候需要面对这种情况：<code>a</code>的取值有<code>0</code>或者<code>1</code>，你想先完成<code>0</code>部分的代码，并且想要代码先通过编译、完成测试。此时你希望的是：在<code>a</code>为<code>1</code>时直接结束代码，那么很明显一个思路是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (a) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        cerr&lt;&lt;<span class="string">&quot;todo&quot;</span>&lt;&lt;<span class="function">std::endl</span></span><br><span class="line"><span class="function">        <span class="title">exit</span><span class="params">(<span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">break</span>;-</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这么写思路是对的，但是有两个问题：</p>
<ul>
<li>麻烦，你要写两行。</li>
<li>你执行代码的时候可能会有多个todo的情况，执行失败之后你不知道哪个todo被触发了。</li>
</ul>
<p>为了避免这个问题，可以使用一个宏代替。也就是<code>moe_rt_todo()</code>宏。</p>
<p>当然，还有一种情况是你想保证在你完成某个todo之前都不允许代码通过编译，那就可以使用<code>moe_todo()</code>宏解决。</p>
<h3 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">moe_assert</span>(a==<span class="number">0</span>);</span><br><span class="line"><span class="built_in">moe_assert</span>(a==<span class="number">0</span>, <span class="string">&quot;Message.&quot;</span>);</span><br><span class="line"><span class="keyword">switch</span> (a) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">moe_rt_todo</span>();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">moe_todo</span>();	<span class="comment">//	不想本代码过编译直到完成这部分代码。</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><p>有一个问题是，现在大多数编辑器都支持<code>TODO</code>高亮，但是以CLion为例，本todo宏就不支持这个高亮。</p>
<h2 id="empty-function-hpp"><a href="#empty-function-hpp" class="headerlink" title="empty_function.hpp"></a>empty_function.hpp</h2><h3 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h3><p>空函数模板。后续的一些函数会用到这个空函数。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> func1 = moe::empty_func&lt;<span class="type">void</span>, <span class="type">int</span>&gt;; <span class="comment">// 输入int，输出void</span></span><br><span class="line"><span class="keyword">auto</span> func2 = moe::empty_func&lt;<span class="type">void</span>&gt;;		<span class="comment">//	无输入，输出void</span></span><br><span class="line"><span class="keyword">auto</span> func3 = moe::empty_func&lt;<span class="type">int</span>&gt;;		<span class="comment">//	无输入，输出int</span></span><br><span class="line"><span class="keyword">auto</span> func4 = moe::empty_func&lt;<span class="type">int</span>, <span class="type">float</span>&gt;;	<span class="comment">//	输入float，输出int</span></span><br></pre></td></tr></table></figure>



<h2 id="debugger-hpp"><a href="#debugger-hpp" class="headerlink" title="debugger.hpp"></a>debugger.hpp</h2><h3 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h3><p>这个库是我虚(zhi)心(jie)借(zhao)鉴(ban)自<a href="https://github.com/sharkdp/dbg-macro.git">sharkdp&#x2F;dbg-macro</a>的。</p>
<p>当然，它是MIT标准，moe是GPL标准，引用代码应该没问题？。。。</p>
<p>大家可以去它的仓库看使用方法。</p>
<h3 id="为什么要引用这个库"><a href="#为什么要引用这个库" class="headerlink" title="为什么要引用这个库"></a>为什么要引用这个库</h3><p>dbg是我在打ACM的时候就使用的宏，它是“输出调试法”的一部分。使用一个宏代替<code>cout</code>手动输出相对高效些。</p>
<p>Rust也在原生支持了这个库。</p>
<h2 id="log-hpp"><a href="#log-hpp" class="headerlink" title="log.hpp"></a>log.hpp</h2><h3 id="介绍-5"><a href="#介绍-5" class="headerlink" title="介绍"></a>介绍</h3><p>这是日志库。分成两种：</p>
<ul>
<li><p>整体使用的<code>STDLog</code>，注册之后在任何位置可以使用。</p>
</li>
<li><p>函数内局部使用的<code>LocalLog</code>，初始化后在生命周期内可以使用。</p>
<p><code>LocalLog</code>支持自动indent。</p>
</li>
</ul>
<h3 id="使用方法-2"><a href="#使用方法-2" class="headerlink" title="使用方法"></a>使用方法</h3><p>注册<code>STDLog</code>：调用<code>moe::register_std_log</code>函数来注册<code>STDLog</code>，参数包括log文件路径、分隔符、每次输出时的header。</p>
<p>使用<code>STDLog</code>输出：调用<code>moe_slog_info()</code>宏。注意这里要求输入的对象支持<code>operator&lt;&lt;</code>，在输出时会使用传入的分隔符来分割各个部分内容。出于设计的简单考虑，没有设计复杂的格式控制方式，建议一次只log一个对象。</p>
<p>新建<code>LocalLog</code>：调用<code>moe_llog</code>宏，返回新建的对象。</p>
<p>使用<code>LocalLog</code>输出：调用<code>LocalLog</code>的<code>info</code>方法即可。</p>
<h2 id="arg-parser-hpp"><a href="#arg-parser-hpp" class="headerlink" title="arg_parser.hpp"></a>arg_parser.hpp</h2><h3 id="介绍-6"><a href="#介绍-6" class="headerlink" title="介绍"></a>介绍</h3><p>用来解析命令行参数的库。</p>
<h3 id="使用方法-3"><a href="#使用方法-3" class="headerlink" title="使用方法"></a>使用方法</h3><p>这个库使用了非常简单的设计方法：库只解析命令行参数，把输入的字符串解析出来，使用者需要传入函数来解析字符串。</p>
<p>举个例子，对于clang这种编译器，可以使用下述方式解析：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CompilerInfo</span> &#123;</span><br><span class="line">    <span class="type">bool</span> help;</span><br><span class="line">    <span class="type">int</span> optiLevel;</span><br><span class="line">    std::string outPath;</span><br><span class="line">    std::vector&lt;std::string&gt; files;</span><br><span class="line">&#125; cInfo&#123;<span class="literal">false</span>, <span class="number">0</span>, <span class="string">&quot;&quot;</span>, &#123; &#125;&#125;;</span><br><span class="line"><span class="keyword">auto</span> argParser = moe::<span class="built_in">ArgParser</span>(<span class="string">&quot;STD Compiler&quot;</span>);</span><br><span class="line">argParser.<span class="built_in">add_option</span>(</span><br><span class="line">    moe::<span class="built_in">ArgOption</span>(</span><br><span class="line">        <span class="string">&#x27;h&#x27;</span>, std::<span class="literal">nullopt</span>, <span class="literal">false</span>, [&amp;cInfo](std::string_view) &#123;</span><br><span class="line">            cInfo.help = <span class="literal">true</span>;</span><br><span class="line">        &#125;, <span class="string">&quot;Print help info before parsing.&quot;</span></span><br><span class="line">    )</span><br><span class="line">);</span><br><span class="line">argParser.<span class="built_in">add_option</span>(</span><br><span class="line">    moe::<span class="built_in">ArgOption</span>(</span><br><span class="line">        <span class="string">&#x27;o&#x27;</span>, std::<span class="literal">nullopt</span>, <span class="literal">true</span>, [&amp;cInfo](std::string_view path) &#123;</span><br><span class="line">            cInfo.outPath = path;</span><br><span class="line">        &#125;, <span class="string">&quot;Output exe file path.&quot;</span></span><br><span class="line">    )</span><br><span class="line">);</span><br><span class="line">argParser.<span class="built_in">add_option</span>(</span><br><span class="line">    moe::<span class="built_in">ArgOption</span>(</span><br><span class="line">        <span class="string">&#x27;O&#x27;</span>, std::<span class="literal">nullopt</span>, <span class="literal">true</span>, [&amp;cInfo](std::string_view optiLevel) &#123;</span><br><span class="line">            std::<span class="built_in">from_chars</span>(optiLevel.<span class="built_in">begin</span>(), optiLevel.<span class="built_in">end</span>(), cInfo.optiLevel);</span><br><span class="line">        &#125;, <span class="string">&quot;Opti level of your compiler.&quot;</span></span><br><span class="line">    )</span><br><span class="line">);</span><br><span class="line">argParser.<span class="built_in">add_func_to_handle_non_option_arg</span>(</span><br><span class="line">    [&amp;cInfo](std::string_view path) &#123;</span><br><span class="line">        cInfo.files.<span class="built_in">emplace_back</span>(path);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line">argParser.<span class="built_in">parse</span>(argc, argv);</span><br></pre></td></tr></table></figure>

<p>解释一下这种设计思路的好处：所有的解析方式都由用户自己定义。可以看出来，这个设计下代码是简单易懂的。</p>
<p>别的命令行参数解析库往往都会支持自动解析，但是我觉得这样会加大代码耦合程度，进而导致代码变得复杂，反而不利于设计。</p>
<h2 id="decorator-hpp"><a href="#decorator-hpp" class="headerlink" title="decorator.hpp"></a>decorator.hpp</h2><h3 id="介绍-7"><a href="#介绍-7" class="headerlink" title="介绍"></a>介绍</h3><p>用于在命令行输出染色字符的库。</p>
<p>原理很简单，命令行染色的本质就是输出一系列字符，然后由shell完成渲染。所以想要染色的时候输出一些字符就行。</p>
<h3 id="使用方法-4"><a href="#使用方法-4" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; moe::<span class="built_in">set_decorator</span>(moe::bg_blue, moe::c_red, moe::d_underline)</span><br><span class="line">          &lt;&lt; <span class="string">&quot;Hello! &quot;</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;How are you?&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; moe::<span class="built_in">set_decorator</span>(moe::bg_cyan, moe::c_black, moe::d_bold)</span><br><span class="line">          &lt;&lt; <span class="string">&quot;Fine, thank you! And you?&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; moe::<span class="built_in">set_decorator</span>(moe::reset);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;End of communication&quot;</span> &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="/../../../../Proj/moe/docs/src_to_doc/set_decorator_demo.png" alt="set_decorator_demo"></p>
<h2 id="time-pro-hpp"><a href="#time-pro-hpp" class="headerlink" title="time_pro.hpp"></a>time_pro.hpp</h2><h3 id="介绍-8"><a href="#介绍-8" class="headerlink" title="介绍"></a>介绍</h3><p>C++17了，C++标准库里居然还没有简单易用的时间获取函数！</p>
<p>这里定义的就是这个。</p>
<h3 id="使用方法-5"><a href="#使用方法-5" class="headerlink" title="使用方法"></a>使用方法</h3><p><code>moe::now::day()</code>、<code>moe::now::hour()</code>、<code>moe::now::minute()</code>、<code>moe::now::second()</code>分别输出<code>i32</code>类型的目前的“日”、“时”、“分”和“秒”。</p>
<p><code>moe:now::formatTime()</code>则输出<code>HH:MM</code>格式的24小时制时间。</p>
<h2 id="restorer-hpp"><a href="#restorer-hpp" class="headerlink" title="restorer.hpp"></a>restorer.hpp</h2><h3 id="介绍-9"><a href="#介绍-9" class="headerlink" title="介绍"></a>介绍</h3><p>在写编译器的时候，有时候会遇到这种场景：我想在函数的开始将<code>a</code>自增1，但是要在函数结束的时候变回去。</p>
<p>在C++这种面相对象语言里，因为会保证在函数结束时析构局部变量，所以可以用类做到这个。</p>
<h3 id="使用方法-6"><a href="#使用方法-6" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">moe_r_set</span>(a, a+<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> b=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">moe_r_set</span>(a, std::<span class="built_in">move</span>(b));	<span class="comment">//	NOLINT</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以保证在返回时a的值变成原来的值。</p>
<p>可以用于自定义类型，但是必须保证：</p>
<ol>
<li>自定义类型有移动赋值函数。</li>
<li>自定义类型右移动构造函数。</li>
</ol>
<h3 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h3><p>目前的设计有一些问题，比如我在模板里就强行要求了<code>newVal</code>（也就是<code>moe_r_set</code>的第二个参数）必须为右值，也就是即使你对<code>int</code>这种基础类型，也必须加<code>std::move</code>——这本来不是问题，但是问题在于：部分编译器会对这个行为加warning，虽然可以通过加<code>// NOLINT</code>来避免warning提示（上面的例子），但是终究还是需要额外的关注。</p>
<p>此外，下面的做法是不行的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> str = std::<span class="built_in">string</span>();</span><br><span class="line"><span class="built_in">moe_r_set</span>(str, <span class="string">&quot;??&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>必须改成<code>moe_r_set(str, std::string(&quot;123&quot;))</code>。</p>
<p>可能在后续版本解决这个问题吧。</p>
<h2 id="一些其他库"><a href="#一些其他库" class="headerlink" title="一些其他库"></a>一些其他库</h2><p>还有一些杂七杂八的库，这里就不专门介绍了，可以去看源码：</p>
<ul>
<li><p>fmt_string.hpp</p>
</li>
<li><p>moe_concept.hpp</p>
<p>这里面的<code>Cloneable</code>是使用智能指针的仿Java<code>Cloneable</code>。</p>
</li>
<li><p>stl_pro.hpp</p>
</li>
</ul>
